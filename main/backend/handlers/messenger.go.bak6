package handlers

import (
	"backend/models"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
)

// GetChatsHandler –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –¥–∏–∞–ª–æ–≥–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
func GetChatsHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID, ok := r.Context().Value("userID").(int)
		if !ok || userID == 0 {
			http.Error(w, `{"success":false,"error":"Unauthorized"}`, http.StatusUnauthorized)
			return
		}

		// –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å JOIN –≤–º–µ—Å—Ç–æ N+1 –∑–∞–ø—Ä–æ—Å–æ–≤
		query := `
			SELECT 
				c.id, c.user1_id, c.user2_id, c.last_message_id, c.last_message_at, c.created_at,
				u.id as other_user_id, u.name, u.last_name, u.avatar, 
CASE WHEN ua.last_seen IS NOT NULL AND (julianday('now') - julianday(ua.last_seen)) * 24 * 60 < 5 THEN 1 ELSE 0 END as is_online,
ua.last_seen,
				m.id as msg_id, m.sender_id, m.content, m.is_read, m.created_at as msg_created_at,
				COALESCE((
					SELECT COUNT(*) 
					FROM messages 
					WHERE chat_id = c.id AND receiver_id = ? AND is_read = 0
				), 0) as unread_count
			FROM chats c
			LEFT JOIN users u ON (
				CASE 
					WHEN c.user1_id = ? THEN c.user2_id 
					ELSE c.user1_id 
				END = u.id
			)
			LEFT JOIN user_activity ua ON u.id = ua.user_id
LEFT JOIN messages m ON c.last_message_id = m.id
			WHERE c.user1_id = ? OR c.user2_id = ?
			ORDER BY c.last_message_at DESC NULLS LAST, c.created_at DESC
		`

		rows, err := db.Query(query, userID, userID, userID, userID)
		if err != nil {
			log.Printf("Error fetching chats: %v", err)
			http.Error(w, "Failed to fetch chats", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		var chats []models.Chat
		for rows.Next() {
			var chat models.Chat
			var otherUser models.User
			var lastMessage models.Message
			var msgID, msgSenderID sql.NullInt64
			var msgContent sql.NullString
			var msgIsRead sql.NullBool
			var msgCreatedAt sql.NullString
			var unreadCount int

			err := rows.Scan(
				&chat.ID, &chat.User1ID, &chat.User2ID,
				&chat.LastMessageID, &chat.LastMessageAt, &chat.CreatedAt,
				&otherUser.ID, &otherUser.Name, &otherUser.LastName,
				&otherUser.Avatar, &otherUser.IsOnline, &otherUser.LastSeen,
				&msgID, &msgSenderID, &msgContent, &msgIsRead, &msgCreatedAt,
				&unreadCount,
			)
			if err != nil {
				log.Printf("Error scanning chat: %v", err)
				continue
			}

			chat.OtherUser = &otherUser
			chat.UnreadCount = unreadCount

			// –ï—Å–ª–∏ –µ—Å—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
			if msgID.Valid {
				lastMessage.ID = int(msgID.Int64)
				if msgSenderID.Valid {
					lastMessage.SenderID = int(msgSenderID.Int64)
				}
				if msgContent.Valid {
					lastMessage.Content = msgContent.String
				}
				if msgIsRead.Valid {
					lastMessage.IsRead = msgIsRead.Bool
				}
				if msgCreatedAt.Valid {
					// –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É –≤ time.Time
					if t, err := time.Parse("2006-01-02 15:04:05", msgCreatedAt.String); err == nil {
						lastMessage.CreatedAt = &t
					}
				}
				chat.LastMessage = &lastMessage
			}

			chats = append(chats, chat)
		}

		if chats == nil {
			chats = []models.Chat{}
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(chats)
	}
}

// GetChatMessagesHandler –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —á–∞—Ç–∞
func GetChatMessagesHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID, ok := r.Context().Value("userID").(int)
		if !ok || userID == 0 {
			http.Error(w, `{"success":false,"error":"Unauthorized"}`, http.StatusUnauthorized)
			return
		}

		// –ü–æ–ª—É—á–∞–µ–º ID —á–∞—Ç–∞ –∏–∑ URL
		pathParts := strings.Split(r.URL.Path, "/")
		if len(pathParts) < 4 {
			http.Error(w, "Invalid chat ID", http.StatusBadRequest)
			return
		}
		chatID, err := strconv.Atoi(pathParts[3])
		if err != nil {
			http.Error(w, "Invalid chat ID", http.StatusBadRequest)
			return
		}

		log.Printf("üì® GetChatMessagesHandler: chatID=%d, userID=%d", chatID, userID)

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —á–∞—Ç–∞
		if !isUserInChat(db, chatID, userID) {
			log.Printf("‚ùå User %d is not in chat %d", userID, chatID)
			http.Error(w, "Access denied", http.StatusForbidden)
			return
		}

		log.Printf("‚úÖ User %d is in chat %d, fetching messages...", userID, chatID)

		// –ü–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
		query := `
			SELECT 
				m.id, m.chat_id, m.sender_id, m.receiver_id, 
				m.content, m.is_read, m.read_at, m.created_at
			FROM messages m
			WHERE m.chat_id = ?
			ORDER BY m.created_at ASC
		`

		rows, err := db.Query(query, chatID)
		if err != nil {
			log.Printf("‚ùå Error fetching messages: %v", err)
			http.Error(w, "Failed to fetch messages", http.StatusInternalServerError)
			return
		}
		defer rows.Close()

		log.Printf("üìä Query executed, scanning rows...")
		var messages []models.Message
		rowCount := 0
		for rows.Next() {
			rowCount++
			var msg models.Message
			var readAtStr, createdAtStr sql.NullString
			
			err := rows.Scan(
&msg.ID, &msg.ChatID, &msg.SenderID, &msg.ReceiverID,
				&msg.Content, &msg.IsRead, &readAtStr, &createdAtStr,
			)
			if err != nil {
				log.Printf("‚ùå Error scanning message row %d: %v", rowCount, err)
				continue
			}
			
			// –ü–∞—Ä—Å–∏–º –¥–∞—Ç—ã
			if createdAtStr.Valid {
				// –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
				formats := []string{
					time.RFC3339Nano,                      // 2006-01-02T15:04:05.999999999Z07:00
					time.RFC3339,                          // 2006-01-02T15:04:05Z07:00
					"2006-01-02 15:04:05.999999-07:00",   // SQLite —Å –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥–∞–º–∏
					"2006-01-02 15:04:05",                 // SQLite –±–µ–∑ –º–∏–∫—Ä–æ—Å–µ–∫—É–Ω–¥
				}
				var t time.Time
				var err error
				for _, format := range formats {
					t, err = time.Parse(format, createdAtStr.String)
					if err == nil {
						msg.CreatedAt = &t
						break
					}
				}
				if err != nil {
					log.Printf("‚ö†Ô∏è Failed to parse created_at: %s, error: %v", createdAtStr.String, err)
				}
			}
			
			if readAtStr.Valid {
				formats := []string{
					time.RFC3339Nano,
					time.RFC3339,
					"2006-01-02 15:04:05.999999-07:00",
					"2006-01-02 15:04:05",
				}
				var t time.Time
				var err error
				for _, format := range formats {
					t, err = time.Parse(format, readAtStr.String)
					if err == nil {
						msg.ReadAt = &t
						break
					}
				}
			}
			log.Printf("‚úÖ Scanned message %d: ID=%d, Content=%s", rowCount, msg.ID, msg.Content)

			// –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–µ
			sender, err := getUserByID(db, msg.SenderID)
			if err == nil {
				msg.Sender = sender
} else {
log.Printf("‚ö†Ô∏è Failed to get sender for message %d: %v", msg.ID, err)
			}

			// –ü–æ–ª—É—á–∞–µ–º attachments
			attachments, err := getMessageAttachments(db, msg.ID)
			if err == nil {
				msg.Attachments = attachments
} else {
log.Printf("‚ö†Ô∏è Failed to get attachments for message %d: %v", msg.ID, err)
			}

			messages = append(messages, msg)
log.Printf("‚úÖ Message %d added to list", msg.ID)
		}

		// –û—Ç–º–µ—á–∞–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
		go markMessagesAsRead(db, chatID, userID)

		if messages == nil {
			messages = []models.Message{}
		}
		log.Printf("‚úÖ Returning %d messages for chat %d", len(messages), chatID)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(messages)
	}
}

// SendMessageHandler –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
func SendMessageHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID, ok := r.Context().Value("userID").(int)
		if !ok || userID == 0 {
			http.Error(w, `{"success":false,"error":"Unauthorized"}`, http.StatusUnauthorized)
			return
		}

		var req struct {
			ReceiverID int    `json:"receiver_id"`
			Content    string `json:"content"`
		}

		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			http.Error(w, "Invalid request body", http.StatusBadRequest)
			return
		}

		if req.ReceiverID == 0 || req.Content == "" {
			http.Error(w, "Receiver ID and content are required", http.StatusBadRequest)
			return
		}

		if req.ReceiverID == userID {
			http.Error(w, "Cannot send message to yourself", http.StatusBadRequest)
			return
		}

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—É—á–∞—Ç–µ–ª—å
		receiverExists, err := userExists(db, req.ReceiverID)
		if err != nil || !receiverExists {
			http.Error(w, "Receiver not found", http.StatusNotFound)
			return
		}

		// –ò—â–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º —á–∞—Ç
		chatID, err := getOrCreateChat(db, userID, req.ReceiverID)
		if err != nil {
			log.Printf("‚ùå Error getting/creating chat: %v", err)
			http.Error(w, "Failed to create chat", http.StatusInternalServerError)
			return
		}

		// –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
		result, err := db.Exec(`
			INSERT INTO messages (chat_id, sender_id, receiver_id, content, created_at)
			VALUES (?, ?, ?, ?, ?)
		`, chatID, userID, req.ReceiverID, req.Content, time.Now())

		if err != nil {
			log.Printf("‚ùå Error creating message: %v", err)
			http.Error(w, "Failed to send message", http.StatusInternalServerError)
			return
		}

		messageID, _ := result.LastInsertId()

		// –û–±–Ω–æ–≤–ª—è–µ–º last_message –≤ —á–∞—Ç–µ
		_, err = db.Exec(`
			UPDATE chats 
			SET last_message_id = ?, last_message_at = ?
			WHERE id = ?
		`, messageID, time.Now(), chatID)

		if err != nil {
			log.Printf("‚ö†Ô∏è Warning: Failed to update chat last_message: %v", err)
		}

		// –ü–æ–ª—É—á–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
		message, err := getMessageByID(db, int(messageID))
		if err != nil {
			log.Printf("‚ùå Error fetching created message: %v", err)
			http.Error(w, "Message sent but failed to fetch", http.StatusInternalServerError)
			return
		}

		log.Printf("‚úÖ Message sent: user %d -> user %d in chat %d", userID, req.ReceiverID, chatID)

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(message)
	}
}

// GetUnreadCountHandler –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
func GetUnreadCountHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID, ok := r.Context().Value("userID").(int)
		if !ok || userID == 0 {
			http.Error(w, `{"success":false,"error":"Unauthorized"}`, http.StatusUnauthorized)
			return
		}

		var count int
		err := db.QueryRow(`
			SELECT COUNT(*) 
			FROM messages 
			WHERE receiver_id = ? AND is_read = 0
		`, userID).Scan(&count)

		if err != nil {
			log.Printf("‚ùå Error counting unread messages: %v", err)
			http.Error(w, "Failed to count unread messages", http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]int{"count": count})
	}
}

// SendMediaMessageHandler –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –º–µ–¥–∏–∞ (—Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ)
func SendMediaMessageHandler(db *sql.DB) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		userID := r.Context().Value("userID").(int)

		// –ü–∞—Ä—Å–∏–º multipart form
		err := r.ParseMultipartForm(50 << 20) // 50 MB max
		if err != nil {
			http.Error(w, "Failed to parse form", http.StatusBadRequest)
			return
		}

		// –ü–æ–ª—É—á–∞–µ–º receiver_id
		receiverIDStr := r.FormValue("receiver_id")
		if receiverIDStr == "" {
			http.Error(w, "Receiver ID is required", http.StatusBadRequest)
			return
		}

		receiverID, err := strconv.Atoi(receiverIDStr)
		if err != nil {
			http.Error(w, "Invalid receiver ID", http.StatusBadRequest)
			return
		}

		if receiverID == userID {
			http.Error(w, "Cannot send message to yourself", http.StatusBadRequest)
			return
		}

		// –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
		content := r.FormValue("content")

		// –ü–æ–ª—É—á–∞–µ–º —Ñ–∞–π–ª—ã
		files := r.MultipartForm.File["media"]
		if len(files) == 0 {
			http.Error(w, "At least one media file is required", http.StatusBadRequest)
			return
		}

		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—É—á–∞—Ç–µ–ª—å
		receiverExists, err := userExists(db, receiverID)
		if err != nil || !receiverExists {
			http.Error(w, "Receiver not found", http.StatusNotFound)
			return
		}

		// –ò—â–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º —á–∞—Ç
		chatID, err := getOrCreateChat(db, userID, receiverID)
		if err != nil {
			log.Printf("‚ùå Error getting/creating chat: %v", err)
			http.Error(w, "Failed to create chat", http.StatusInternalServerError)
			return
		}

		// –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
		result, err := db.Exec(`
			INSERT INTO messages (chat_id, sender_id, receiver_id, content, created_at)
			VALUES (?, ?, ?, ?, ?)
		`, chatID, userID, receiverID, content, time.Now())

		if err != nil {
			log.Printf("‚ùå Error creating message: %v", err)
			http.Error(w, "Failed to send message", http.StatusInternalServerError)
			return
		}

		messageID, _ := result.LastInsertId()

		// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª—ã –∏ —Å–æ–∑–¥–∞–µ–º attachments
		var attachments []models.MessageAttachment
		for _, fileHeader := range files {
			file, err := fileHeader.Open()
			if err != nil {
				log.Printf("‚ùå Error opening file: %v", err)
				continue
			}
			defer file.Close()

			// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ñ–∞–π–ª–∞
			fileType := "file" // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é - –æ–±—ã—á–Ω—ã–π —Ñ–∞–π–ª
			contentType := fileHeader.Header.Get("Content-Type")

			if strings.HasPrefix(contentType, "image/") {
				fileType = "image"
			} else if strings.HasPrefix(contentType, "video/") {
				fileType = "video"
			}

			log.Printf("üìé File type detected: %s (Content-Type: %s)", fileType, contentType)

			// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
			filePath, err := saveUploadedFile(file, fileHeader.Filename)
			if err != nil {
				log.Printf("‚ùå Error saving file: %v", err)
				continue
			}

			// –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –ë–î
			attachResult, err := db.Exec(`
				INSERT INTO message_attachments (message_id, file_path, file_type, file_size, created_at)
				VALUES (?, ?, ?, ?, ?)
			`, messageID, filePath, fileType, fileHeader.Size, time.Now())

			if err != nil {
				log.Printf("‚ùå Error creating attachment: %v", err)
				continue
			}

			attachID, _ := attachResult.LastInsertId()
			attachments = append(attachments, models.MessageAttachment{
				ID:        int(attachID),
				MessageID: int(messageID),
				FilePath:  filePath,
				FileType:  fileType,
				FileSize:  int(fileHeader.Size),
				CreatedAt: time.Now(),
			})
		}

		// –û–±–Ω–æ–≤–ª—è–µ–º last_message –≤ —á–∞—Ç–µ
		_, err = db.Exec(`
			UPDATE chats 
			SET last_message_id = ?, last_message_at = ?
			WHERE id = ?
		`, messageID, time.Now(), chatID)

		if err != nil {
			log.Printf("‚ö†Ô∏è Warning: Failed to update chat last_message: %v", err)
		}

		// –ü–æ–ª—É—á–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
		message, err := getMessageByID(db, int(messageID))
		if err != nil {
			log.Printf("‚ùå Error fetching created message: %v", err)
			http.Error(w, "Message sent but failed to fetch", http.StatusInternalServerError)
			return
		}

		// –î–æ–±–∞–≤–ª—è–µ–º attachments –∫ —Å–æ–æ–±—â–µ–Ω–∏—é
		message.Attachments = attachments

		log.Printf("‚úÖ Media message sent: user %d -> user %d in chat %d (%d attachments)", userID, receiverID, chatID, len(attachments))

		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(message)
	}
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

func getOrCreateChat(db *sql.DB, user1ID, user2ID int) (int, error) {
	// –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ—Ä—è–¥–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–º–µ–Ω—å—à–∏–π ID –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–≤—ã–π)
	if user1ID > user2ID {
		user1ID, user2ID = user2ID, user1ID
	}

	// –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —á–∞—Ç
	var chatID int
	err := db.QueryRow(`
		SELECT id FROM chats 
		WHERE (user1_id = ? AND user2_id = ?) OR (user1_id = ? AND user2_id = ?)
	`, user1ID, user2ID, user2ID, user1ID).Scan(&chatID)

	if err == nil {
		return chatID, nil
	}

	// –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —á–∞—Ç
	result, err := db.Exec(`
		INSERT INTO chats (user1_id, user2_id, created_at)
		VALUES (?, ?, ?)
	`, user1ID, user2ID, time.Now())

	if err != nil {
		return 0, err
	}

	id, err := result.LastInsertId()
	return int(id), err
}

func isUserInChat(db *sql.DB, chatID, userID int) bool {
	var count int
	err := db.QueryRow(`
		SELECT COUNT(*) FROM chats 
		WHERE id = ? AND (user1_id = ? OR user2_id = ?)
	`, chatID, userID, userID).Scan(&count)

	return err == nil && count > 0
}

func getMessageByID(db *sql.DB, messageID int) (*models.Message, error) {
	var msg models.Message
	err := db.QueryRow(`
		SELECT id, chat_id, sender_id, receiver_id, content, is_read, read_at, created_at
		FROM messages WHERE id = ?
	`, messageID).Scan(
		&msg.ID, &msg.ChatID, &msg.SenderID, &msg.ReceiverID,
		&msg.Content, &msg.IsRead, &msg.ReadAt, &msg.CreatedAt,
	)

	if err != nil {
		return nil, err
	}

	// –ü–æ–ª—É—á–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
	sender, err := getUserByID(db, msg.SenderID)
	if err == nil {
		msg.Sender = sender
} else {
log.Printf("‚ö†Ô∏è Failed to get sender for message %d: %v", msg.ID, err)
	}

	// –ü–æ–ª—É—á–∞–µ–º attachments
	attachments, err := getMessageAttachments(db, messageID)
	if err == nil {
		msg.Attachments = attachments
} else {
log.Printf("‚ö†Ô∏è Failed to get attachments for message %d: %v", msg.ID, err)
	}

	return &msg, nil
}

func getMessageAttachments(db *sql.DB, messageID int) ([]models.MessageAttachment, error) {
	rows, err := db.Query(`
		SELECT id, message_id, file_path, file_type, file_size, created_at
		FROM message_attachments
		WHERE message_id = ?
		ORDER BY created_at ASC
	`, messageID)

	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var attachments []models.MessageAttachment
	for rows.Next() {
		var attachment models.MessageAttachment
		err := rows.Scan(
			&attachment.ID, &attachment.MessageID, &attachment.FilePath,
			&attachment.FileType, &attachment.FileSize, &attachment.CreatedAt,
		)
		if err != nil {
			log.Printf("‚ö†Ô∏è Error scanning attachment: %v", err)
			continue
		}
		attachments = append(attachments, attachment)
	}

	return attachments, nil
}

func saveUploadedFile(file multipart.File, filename string) (string, error) {
	// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
	ext := filepath.Ext(filename)
	newFilename := fmt.Sprintf("%s%s", uuid.New().String(), ext)

	// –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –¥–ª—è –º–µ–¥–∏–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
	uploadDir := "../../uploads/messages"
	if err := os.MkdirAll(uploadDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create directory: %v", err)
	}

	// –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
	filePath := filepath.Join(uploadDir, newFilename)
	dst, err := os.Create(filePath)
	if err != nil {
		return "", fmt.Errorf("failed to create file: %v", err)
	}
	defer dst.Close()

	if _, err := io.Copy(dst, file); err != nil {
		return "", fmt.Errorf("failed to save file: %v", err)
	}

	// –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –¥–ª—è URL
	return fmt.Sprintf("/uploads/messages/%s", newFilename), nil
}

func getUnreadCount(db *sql.DB, chatID, userID int) (int, error) {
	var count int
	err := db.QueryRow(`
		SELECT COUNT(*) FROM messages 
		WHERE chat_id = ? AND receiver_id = ? AND is_read = 0
	`, chatID, userID).Scan(&count)

	return count, err
}

func markMessagesAsRead(db *sql.DB, chatID, userID int) {
	_, err := db.Exec(`
		UPDATE messages 
		SET is_read = 1, read_at = ?
		WHERE chat_id = ? AND receiver_id = ? AND is_read = 0
	`, time.Now(), chatID, userID)

	if err != nil {
		log.Printf("‚ö†Ô∏è Warning: Failed to mark messages as read: %v", err)
	}
}

func userExists(db *sql.DB, userID int) (bool, error) {
	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM users WHERE id = ?", userID).Scan(&count)
	return count > 0, err
}

func getUserByID(db *sql.DB, userID int) (*models.User, error) {
	var user models.User
	var lastSeen sql.NullTime

	err := db.QueryRow(`
		SELECT u.id, u.email, u.name, u.last_name, u.avatar, u.cover_photo, u.bio, 
		       u.location, u.phone, u.created_at, ua.last_seen
		FROM users u
		LEFT JOIN user_activity ua ON u.id = ua.user_id
		WHERE u.id = ?
	`, userID).Scan(
		&user.ID, &user.Email, &user.Name, &user.LastName, &user.Avatar,
		&user.CoverPhoto, &user.Bio, &user.Location, &user.Phone,
		&user.CreatedAt, &lastSeen,
	)

	if err != nil {
		return nil, err
	}

	// –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º last_seen –µ—Å–ª–∏ –µ—Å—Ç—å
	if lastSeen.Valid {
		user.LastSeen = &lastSeen.Time
		// –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–Ω–ª–∞–π–Ω —Å—Ç–∞—Ç—É—Å (–∞–∫—Ç–∏–≤–µ–Ω –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –º–∏–Ω—É—Ç)
		user.IsOnline = time.Since(lastSeen.Time) < 5*time.Minute
	} else {
		user.IsOnline = false
	}

	return &user, nil
}
